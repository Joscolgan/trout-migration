g_female
colnames(g_female)
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
seq_along(g_female)
hist(g_female[[i]]
)
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
for (i in seq_along(g_female)) {
plot(g_female[[i]],type='hist')
}
for (i in seq_along(g_female)) {
ggplot(g_female[[i]], g_female[[i]]) + geom_histogram()
}
library(ggplot2)
for (i in seq_along(g_female)) {
ggplot(g_female[[i]], g_female[[i]]) + geom_histogram()
}
for (i in seq_along(g_female)) {
ggplot(g_female[[i]], aes(g_female[[i]])) + geom_histogram()
}
for (i in seq_along(g_female)) {
ggplot(data.frame(g_female[[i]]), aes(g_female[[i]])) + geom_histogram()
}
ggplot(data.frame(g_female[[i]]), aes(g_female[[i]])) + geom_histogram()
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
for (i in seq_along(g_female)) {
ggplot(data.frame(g_female[[i]]), aes(g_female[[i]])) + geom_histogram()
}
ggplot(data.frame(g_female[[i]]), aes(g_female[[i]])) + geom_histogram()
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
lapply(
l,
function(i) ggplot(g_female, aes(x=g_female)) + geom_histogram(binwidth=.5)
)
lapply(
g_female,
function(i) ggplot(g_female, aes(x=g_female)) + geom_histogram(binwidth=.5)
)
d <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(d,aes(x = grp, y = x)) + geom_boxplot()
p2 <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(p2,aes(x = grp, y = x)) + geom_histogram()
p2
g_female
?numbers
p2
# Plot histograms
p2 <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(p2) +
geom_histogram(aes(x)) +
facet_wrap(~grp)
#' set up a reporter to collect data on the genotype of the males
vars <- c("who", "g")
agents <- c("males","females")
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' set up a reporter to collect data on the genotype of the females
agents <- "females"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df2 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df2) <- vars
df2
#' specifiy the variables we won't to collect from the model
vars <- c("who", "g" ,"color")
#' set up a reporter to collect data on the genotype of the males
agents <- "males"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' examine the values
summary(df1$g)
hist(df1$g)
#' set up a reporter to collect data on the genotype of the females
agents <- "females"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df2 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df2) <- vars
df2
#' specifiy the variables we won't to collect from the model
vars <- c("who", "g" ,"breed")
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' specifiy the variables we won't to collect from the model
vars <- c("who", "g" ,"breed")
#' set up a reporter to collect data on the genotype of the males
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' specifiy the variables we won't to collect from the model
vars <- c("who", "g" ,"sex")
#' set up a reporter to collect data on the genotype of the males
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("who", "g" ,"sex")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df3 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df3) <- vars
df3
#' examine the values
summary(df3$g)
hist(df3$g)
reporters
#' run the model for 5 by 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort females`
test$`map [x -> [g] of x ] sort turtles`
test
unlist(test)
test
class(test)
#' setup the model
NLCommand("setup")
#' run the model for 5 by 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [who] of x ] sort turtles`
test$`map [x -> [g] of x ] sort females`
test$`map [x -> [g] of x ] sort turtles`
g_turtles <- test$`map [x -> [g] of x ] sort turtles`
g_turtles
test$`map [x -> [sex] of x ] sort turtles`
unlist(test$`map [x -> [sex] of x ] sort turtles`)
mydata <- cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`)
)
mydata
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`)
))
head(mydata)
tail(mydata)
test
test$ticks
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df3 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df3) <- vars
df3
#' examine the values, note this combines the values for both sexes
summary(df3$g)
hist(df3$g)
#' setup the model
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df3 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df3) <- vars
df3
#' examine the values, note this combines the values for both sexes
summary(df3$g)
hist(df3$g)
#' run the model for 5 by 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`), unlist(test$`map [x -> [ticks] of x ] sort turtles`)
))
head(mydata)
#' rename the variables
mydata = rename(mydata, sex = X1, g = X2, iteration = x3)
library(tid)
library(tidyverse)
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = x3)
names(mydata)
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3)
head(mydata)
tail(mydata)
#' plot the data
mydata %>% ggplot(mydata) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' plot the data
ggplot(mydata) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
class(mydata$g)
#' make sure g is classified as numeric
mydata$g <- as.numeric(mydata$g)
#' plot the data
ggplot(mydata) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
mydata
df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`), unlist(test$`map [x -> [ticks] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
#' plot the data
ggplot(mydata) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' plot the data
filter(mydata, sex == "male") %>% ggplot(mydata) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
filter(mydata, sex == "male")
#' plot the data
filter(mydata, sex == "male") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
filter(mydata, sex == "female") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' setup the model
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df3 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df3) <- vars
df3
#' examine the values, note this combines the values for both sexes
summary(df3$g)
hist(df3$g)
#' run the model for 5 by 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`), unlist(test$`map [x -> [ticks] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
tail(mydata)
#' use clusters to run multiple versions of the model
library(parallel)
processors <- detectCores()
processors
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous")
#' setup the model
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df3 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df3) <- vars
df3
#' examine the values, note this combines the values for both sexes
summary(df3$g)
hist(df3$g)
#' run the model for 5 by 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`), unlist(test$`map [x -> [ticks] of x ] sort turtles`),unlist(test$`map [x -> [anadromous] of x ] sort turtles`)
))
mydata
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
#' first for males
filter(mydata, sex == "male") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' now for females
filter(mydata, sex == "female") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' plot individual histograms for each sampling period in base R
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
#' plot box plots for each sampling period using ggplot
p1 <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(p1,aes(x = grp, y = x)) + geom_boxplot()
filter(mydata, sex == "male", anadromous=="TRUE")
filter(mydata, sex == "male", anadromous=="FALSE")
#' filter by resident males
filter(mydata, sex == "male", anadromous=="FALSE") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
Cl <- makeCluster(processors)
Cl
cl
Cl
stopCluster(Cl)
NLQuit()
#' load the libraries
library(RNetLogo)
nl.path <- "C:\\Program Files\\NetLogo 6.0.4\\app\\"
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
nl.jarname = "netlogo-6.0.4.jar"
NLStart(nl.path, nl.jarname=nl.jarname)
NLLoadModel(paste(nl.path,model.path,sep=""))
NLQuit()
#' the initialization function
prepro <- function(dummy, gui, nl.path, model.path) {
library(RNetLogo)
NLStart(nl.path, gui=gui)
NLLoadModel(model.path)
}
#' the simulation function
simfun <- function(x) {
NLCommand("print ",x)
NLCommand("set density", x)
NLCommand("setup")
NLCommand("go")
NLCommand("print count turtles")
ret <- data.frame(x, NLReport("count turtles"))
names(ret) <- c("x","turtles")
return(ret)
}
#' the quit function
postpro <- function(x) {
NLQuit()
}
# load the parallel package, if not already done
require(parallel)
# detect the number of cores available
processors <- detectCores()
# create cluster
Cl <- makeCluster(processors)
# set variables for the start up process
# adapt path appropriate (or set an environment variable NETLOGO_PATH)
gui <- TRUE
nl.path <- "C:\\Program Files\\NetLogo 6.0.4\\app\\"
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
nl.jarname = "netlogo-6.0.4.jar"
# load NetLogo in each processor/core
invisible(parLapply(Cl, 1:processors, prepro, gui=gui,
nl.path=nl.path, model.path=model.path,
nl.jarname=nl.jarname))
# load NetLogo in each processor/core
invisible(parLapply(Cl, 1:processors, prepro, gui=gui,
nl.path=nl.path, model.path=model.path))
prepro
# detect the number of cores available
processors <- detectCores()
processors
# create a cluster
cl <- makeCluster(processors)
cl
# the initialization function
prepro <- function(dummy, gui, nl.path, model.path) {
library(RNetLogo)
NLStart(nl.path, gui=gui)
NLLoadModel(model.path)
}
simfun <- function(density) {
sim <- function(density) {
NLCommand("set density ", density, "setup")
NLDoCommandWhile("any? turtles", "go");
ret <- NLReport("(burned-trees / initial-trees) * 100")
return(ret)
}
lapply(density, function(x) replicate(20, sim(x)))
}
# the quit function
postpro <- function(x) {
NLQuit()
}
# set variables for the start up process
# adapt path appropriate (or set an environment variable NETLOGO_PATH)
gui <- TRUE
nl.path <- Sys.getenv("NETLOGO_PATH", "C:\\Program Files\\NetLogo 6.0.4\\app\\")
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
# load NetLogo in each processor/core
invisible(parLapply(cl,
1:processors,
prepro,
gui=gui,
nl.path=nl.path,
model.path=model.path)
)
nl.path <- Sys.getenv("NETLOGO_PATH", "C:\\Program Files\\NetLogo 6.0.4\\app")
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
# load NetLogo in each processor/core
invisible(parLapply(cl,
1:processors,
prepro,
gui=gui,
nl.path=nl.path,
model.path=model.path)
)
library(rJava)
library(RNetLogo)
# load the parallel package
library(parallel)
# detect the number of cores available
processors <- detectCores()
processors
# create a cluster
cl <- makeCluster(processors)
cl
# the initialization function
prepro <- function(dummy, gui, nl.path, model.path) {
library(RNetLogo)
NLStart(nl.path, gui=gui,nl.jarname = "netlogo-6.0.4.jar")
NLLoadModel(model.path)
}
simfun <- function(density) {
sim <- function(density) {
NLCommand("set density ", density, "setup")
NLDoCommandWhile("any? turtles", "go");
ret <- NLReport("(burned-trees / initial-trees) * 100")
return(ret)
}
lapply(density, function(x) replicate(20, sim(x)))
}
# the quit function
postpro <- function(x) {
NLQuit()
}
# set variables for the start up process
# adapt path appropriate (or set an environment variable NETLOGO_PATH)
gui <- TRUE
nl.path <- "C:\\Program Files\\NetLogo 6.0.4\\app"
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
# load NetLogo in each processor/core
invisible(parLapply(cl,
1:processors,
prepro,
gui=gui,
nl.path=nl.path,
model.path=model.path)
)
### Run over these 11 densities
d <- seq(55, 65, 1)
result.par <- parSapply(cl, d, simfun) # runs the simfunfunction over  clusters varying by density
result.par
burned.df <- data.frame(density=rep(55:65,each=20), pctburned=unlist(result.par))
library(ggplot2)
ggplot(burned.df, aes(x=factor(density), y=pctburned)) + geom_boxplot(alpha=.1) + geom_point()
# Quit NetLogo in each processor/core
invisible(parLapply(cl, 1:processors, postpro))
# stop cluster
stopCluster(cl)
result.par
simfun
d
cl
# Quit NetLogo in each processor/core
invisible(parLapply(cl, 1:processors, postpro))
# stop cluster
stopCluster(cl)
